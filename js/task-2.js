/* Потрібно створити гру хрестики/нулики.
Відмалюй розмітку ігрового поля для контейнера з класом "content",
для кожної клітини застосуй клас "item".
Реалізуй делегування подій на ігровому полі для можливості ходу.
Скріпт має самостійно визначити переможця гри 
та виводити модальне вікно з переможцем (Х/0).
Для історії ходів наших гравців (Х/0) потрібно, щоб кожна клітина
ігрового поля містила дата атрибут id.
Створи скрипт для перевірки виграшної комбінації, 
список всіх можливих виграшних комбінайцій знаходиться в масиві combination.
Для виводу модального вікна застосуй бібліотеку basiclighbox.
Після визначення переможця підготуй ігрове поле для наступної гри.
*/

const combination = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
    [1, 4, 7],
    [2, 5, 8],
    [1, 5, 9],
    [3, 5, 7],
    [3, 6, 9]
]

const content = document.querySelector(".content");
const historyX = []; // щоб запамятовувати ходи Х
const historyO = []; // щоб запамятовувати ходи 0
let player = 'X'; // створюємо гравця за допомогою let, бо він буде змінюватися - перший походив, наступним буде другий

content.addEventListener("click", handleClick) // навішуємо слухача події на контейнер (делегування подій)



// відмалюємо клітинки, let починаємо з 1, бо в масиві немає 0
function createMarkup() {
    let markup = ''
    for (let i = 1; i <= 9; i++) {
        markup += `<div class="item" data-id="${i}"></div>`
    }

    content.innerHTML = markup; // тут використовуємо innerHTML, бо він видалить все і сторить все зново

}

createMarkup();

// event.target === event.currentTarget - якщо клік поза гральним полем
// event.target.textContent - якщо клітинка грального поля вже заповнена
function handleClick(event) {
    if (event.target === event.currentTarget || event.target.textContent) {
        return;
    }

    // отримуємо id як рядок і перетворюємо його на цифрове значення 
    const id = Number(event.target.dataset.id);
    console.log(id); // спрацює для виведенні в консоль, коли клікнути на квадратику грального поля

    let isWinner = false; // створює змінну, яка нам покаже, хто виграв, і по замовченню ставимо false, бо спочатку в нас немає переможців

    if (player === 'X') {
        historyX.push(id); // зберігаємо ходи Х
        isWinner = historyX.length >= 3 ? checkWinner(historyX) : false;
        // використовуємо тернарний оператор для порівняння
        // Сама функція буде порівнювати ходи з масивом виграшних комбінацій
        // і якщо є співпадіння, то isWinner стане true, тобто цей гравець переміг
        // але спочатку вона перевіряє, чи зробив гравець мінімум 3 ходи, 
        // бо саме стільки потрібно для отримання однієї з виграшних комбінацій.
        // Якщо ходів менше, немає сенсу виконувати функцію і повертаємо false
    } else {
        historyO.push(id);
        isWinner = historyO.length >= 3 ? checkWinner(historyO) : false;
    }

    // тепер використовуємо бібліотеку basiclighbox для виводу модального вікна
    // бібліотека підключена за допомогою CDN, тому в нас є до неї доступ 
    // - звертаємося та викликаємо потрібний метод + всередину передаємо рядок із розміткою
    if (isWinner) {
        const instance = basicLightbox.create(`
            <div class="box">
            <h1>Player - ${player} is winner</h1>
            </div>
        `)

        instance.show(); // це написано в документації, що треба викликати ось так

        // тепер робимо функцію, що буде очищувати поле - готувати до наступної гри
        resetGame();
        return; // робимо, бо далі нічого виконувати не будемо
    }

    // далі пишемо код на випадок, якщо не виграли
    event.target.textContent = player; // додаємо імя гравця
    player = player === 'X' ? 'O' : 'X'; // змінюємо поточного гравця на протилежного

    // якщо нічия - один із варіантів реалізації
    const lose = [...content.children].every(item => item.textContent);
    if (lose) {
        resetGame();
    }

}

function checkWinner(arr) {
    return combination.some(item => item.every(id => arr.includes(id))) // перевіряємо, щоб хоч один із результатів був вірний, тобто відпоаідав якомусь із початкового масиву (див.вище)
}

// створюємо функцію, що буде очищати наше ігрове поле
function resetGame() {
    createMarkup();
    player = 'X';
    historyX.splice(0);
    historyO.splice(0);
}

